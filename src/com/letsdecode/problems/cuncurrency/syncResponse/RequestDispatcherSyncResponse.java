package com.letsdecode.problems.cuncurrency.syncResponse;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;

public class RequestDispatcherSyncResponse implements IDispatcher {
	private ExecutorService theadPool = Executors.newCachedThreadPool();
	private LinkedBlockingQueue<Task> workerQueue = new LinkedBlockingQueue<Task> ();
	protected AtomicBoolean stop = new AtomicBoolean();

	@Override
	public void doGet(HttpRequest req, HttpResponse res) {
		workerQueue.add(new Task(req, res));
	}

	public void startDispatcher() {
		for (Task t : workerQueue) {
			this.theadPool.submit(t);
			if (stop.get()) {
				break;
			}
		}
	}

	public void shutdown() {
		stop.set(true);
	}

	class Task implements Runnable {
		public HttpRequest req;
		public HttpResponse res;
		public String result;

		public Task(HttpRequest req, HttpResponse res) {
			this.req = req;
			this.res = res;
		}

		@Override
		public void run() {
			// /do some IO
			String res = ""; // res generated by an IO operation
			setResult(res);
			sendResponse(this);
		}

		public void setResult(String result) {
			this.result = result;
		}
	}

	protected void sendResponse(Task t) {
		t.res.write(t.result);
	}
}
